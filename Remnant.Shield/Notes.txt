
NOTE: if you want to pass message parameters and using interpolation message, ($) make sure to use {{0}} to escape

SPLIT CFG TO CLASS

--> Currently handling only one placeholder on registered message, cause raise can pass only 1 value 
			may want to add params to Raise....will see

Other ideas
	- make methods a class that get s derived from
		- for example the base class can check attributes and perform pre and post execution things
		- the class that implements method classes can construct all
	- remember = MethodBase.GetCurrentMethod();

Extra ideas : blobs
	- what if binary with data is stored as a blob, process reads blob and call the bin execution with the data
		- if binary has dependencies, using ex are in header/metadata links to other blobs binaries which is also read
			and loaded as binary code for execution
	- that means deployment of binaries are to blobs, versioned, snapshots. meta, and a process is generic, doesnt know what gets executed
	- maybe data should be stored separately, with meta pointing to where it must be used for execution
	- blob binaries can be safed to file and only update if blob bin changed

- evaluators
- rules
	buss/sys
	limits, evaluatrors?

	register message used as base
		- can contain placeholders
		- sheild exceptions will use paramname basically only for null exception check

	- caller message overrides all 
		- base message iro of placeholders
		- paramname is ignored
		- message can contain placedholders but must then pass it before raise as params objects, 2nd parameter


		- specify call message
			- if contains ph then look for 2nd pass params (for null the paramname is inferred or overwritten by 2nd param)
					- overrides base msg
			- if no ph, then use it as is and override the base msg
					- but if base msg has ph, use call msg as param

					if no assertion and and base has ph, use for ph otherwise overrides, if override but itself contains ph -> it has no way to get params for it is not an assertion


													callerMessage						baseMessage
placeholders								n																y										- overrides? user as ph?
placeholders								y																n									
placeholders								n																y									
placeholders								n																n															

													callerMessage						baseMessage
placeholders								-																y										
placeholders								y																n									
placeholders								n																y									
placeholders								n																n												


RESULT: if no assert, and a message is defined/registered for an exception, that message will be used, if contains ph, on raise whatever is passed will be used as value for ph, if no ph whatever is passed on raise will be ignored
							but if the registered exception has no message, what is passed on raise will be the message (note if the message contains ph the ph will not be replaced) and
							lastly, if no messages specified the exception will use its own message


